---
title: "Lab 3. Iteration & Apply"
author: "Dr. Jared Joseph"
format:
  html:
    self-contained: true
editor: source
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}

```

## Introduction

Click here to access the lab on Github Classroom: [Github Classroom Assignment for Lab 3: Iteration & Apply](https://moodle.smith.edu/mod/url/view.php?id=1018595)

Both `for()` loops and the apply functions greatly expand the scope of tasks we can accomplish. Combined with our new knowledge of functions, these tools *drastically* increase what we are able to do. The ability to solve a problem, and then automatically apply that solution to an arbitrary number of cases is amazing.

Today we will be practicing this increase in scale by working with some data on banned books. While (I think) this data is interesting, it is important to keep in mind the skill we are focusing on is learning to iterate in R, rather than data analysis. The thing we are iterating on is largely arbitrary; though each case will offer its own challenges. Just keep in mind that this dataframe could easily be a collection of files to modify, a list of web addresses to scrape, or configurations for simulations to run.

## The Data

The data we will be using today comes from [PEN America's Book Bans database](https://pen.org/issue/book-bans/). This database attempts to catalog all books banned in US schools between July 2021 and June 2022. While it is impossible to know if this is all of the bans, and it does not account for books being un-banned later, it is still quite the dataset to look through.

::: {.callout-tip}
I've provided a CSV version of the database in the `data/` directory of this project, as well as a copy of the data documentation in the `docs/` directory. Be sure to refer to it as you work.
:::

:::{.callout-note}
### Question 1

Load in the banned books CSV and assign it to an object named `banned_books`
:::

```{r}

# <REPLACE THIS COMMENT WITH YOR ANSWER>

banned_books = read.csv("data/banned_books.csv")
```

## Tidying the Title

We have some un-tidy data in our banned books dataframe, namely that the `Title` column contains both the title, and the title of the series if it is part of one. We should fix that.

:::{.callout-note}
### Question 2

Use either a `for()` loop or an apply family function to go over the `Title` column of `banned_books`. Your final output should be a dataframe with new columns that contain each of the following:

* A logical if it was part of a series
* The name of the series if it had one
* A clean title for the book

The following functions will be helpful; be sure to read about them and test them out:

* `strsplit()`
* `trimws()`
* `grepl()`
* `gsub()`

:::

```{r}

# <REPLACE THIS COMMENT WITH YOR ANSWER>

# A lot of freedom here. Their methods could be wildly different from mine!
# As long as their output is the same, I don't care.
# Students can do either a for loop or apply here. Standards differ slightly
# The following should always be considered:

# git @ ???
#   Be checking their commits. Should really be pointing out sub-par commits

# code style @ ???
#   A lot of variation possible, most likely not past near standard. If people
#   are still hardly commenting at all, it needs to be mentioned.

## For Loop Strategy -----------------------------------------------------------

# Iteration @ Near Standard
#   Using loops

# Data Structures @ ???
#   Depends on the structures they employ. My example uses dataframes, so would
#   be at Progressing Toward Standard

## Apply Strategy --------------------------------------------------------------

# Iteration @ Meets Standard
#   Using apply functions

# Data Structures @ ???
#   Depends on the structures they employ. My example here uses lists,
#   so near standard

# Functions @ ???
#   Depends on how they build their function for the apply. Mine here would
#   be at Progressing Toward Standard given it has no error checking and
#   can only really work on a specific input.
#   Bump them higher if they do a better job!

# FOR LOOP ---------------------------------------------------------------------

# make dataframe for new info
book_series = data.frame("title" = banned_books$Title, "clean_title" = NA, "series" = NA, "series_title" = NA)

for(book in book_series$title){
  
  # is the book part of a series?
  if(grepl(pattern =  "Series)", x = book, ignore.case = TRUE)){
    
    # if so, set series to TRUE
    book_series[book_series$title == book, "series"] = TRUE
    
    # split the series title from book title
    splits = strsplit(book, split = "(", fixed = TRUE)
    
    # extract clean title
    book_series[book_series$title == book, "clean_title"] = trimws(splits[[1]][1])
    
    # clean series name
    book_series[book_series$title == book, "series_title"] = gsub(" Series)", "", splits[[1]][2])
    
  } else {
    
    # otherwise, set series to false
    book_series[book_series$title == book, "series"] = FALSE
    
    # and copy current title to clean
    book_series[book_series$title == book, "clean_title"] = book
  }
  
}

# combine dfs
banned_books = cbind(banned_books, book_series[, c("clean_title", "series", "series_title")])

# APPLY ------------------------------------------------------------------------

book_series = lapply(banned_books$Title, FUN = function(book){
  
  # make output df
  output_df = data.frame("Title" = book, "clean_title" = NA, "series" = NA, "series_title" = NA)
  
  # is the book part of a series?
  if(grepl(pattern =  "Series)", x = book, ignore.case = TRUE)){
    
    # is so, set series to TRUE
    output_df[output_df$Title == book, "series"] = TRUE
    
    # split the series title from book title
    splits = strsplit(book, split = "(", fixed = TRUE)
    
    # extract clean title
    output_df[output_df$Title == book, "clean_title"] = trimws(splits[[1]][1])
    
    # clean series name
    output_df[output_df$Title == book, "series_title"] = gsub(" Series)", "", splits[[1]][2])
    
  } else {
    
    # otherwise, set series to false
    output_df[output_df$Title == book, "series"] = FALSE
    
    # and copy current title to clean
    output_df[output_df$Title == book, "clean_title"] = book
  }

  # return
  return(output_df)
  
})

# combine list elements
book_series = do.call(rbind, book_series)

# combine dfs
banned_books = cbind(banned_books, book_series[, c("clean_title", "series", "series_title")])
```

## Splitting the Data

The challenge question will be looking at banned books by state, so we are going to split the main dataframe in preparation. Rather than typing out and sub-setting each manually, we will use a `for()` loop to do so.

:::{.callout-note}
### Question 3

Use a `for()` loop to iterate through each state, and sub-set the `banned_books` dataframe by that state. You should store your results in the `state_books` list provided.

You want to end up with a list, `state_books`, that has an element for each state that appeared in our dataset, with the content of that element being a dataframe of all the books banned in that state.

**HINT:** The `unique()` function will be helpful for building your loop. When given a vector it will return all the unique values in that vector.
:::

```{r}

# Create output list
state_books = list()

#<REPLACE THIS COMMENT WITH YOR ANSWER>

# iteration @ Near Standard
# Data Structures @ Near Standard

for(state in unique(banned_books$State)){
  
  # assign a subset dataframe for each state to a corresponding element in list.
  state_books[[state]] = banned_books[banned_books$State == state, ]
  
}
```

## Getting Meta-Data

We know the names of these banned books, but that doesn't tell us much. We're going to use the Google API to try and get more information. I'm going to provide a function for you to use below. What it does is query the Google books API, and return the first result for a search on a book's name. You will use it in the following question. *You will need the `jsonlite` package installed.*

```{r}
# Function to get book info

get_book_info = function(book_name, author_name){
  
  # construct api call
  api_call = paste0("https://www.googleapis.com/books/v1/volumes?maxResults=1&q=name=", book_name, "&inauthor=", author_name)
  
  # get the raw json data from books api
  book_info = jsonlite::fromJSON(URLencode(api_call))
  
  # get the info elements
  info_list = as.list(book_info$items$volumeInfo)
  
  # return
  return(info_list)
}
```

Look at the example output to understand the structure of the returned object.

```{r, eval=FALSE}
example = get_book_info(book_name = "Dune", author_name = "Frank Herbert")

View(example)
```

:::{.callout-warning}
### CHALLANGE QUESTION

Using the provided `get_book_info()` function, get some meta-data for each of the banned books in the database *for Indiana only* (it takes forever otherwise). We want the publisher, ISBN 13 number, page count, maturity rating, and description.
:::

```{r}

# No idea how people will tackle this.
# Anything goes! So long as the output works.
# Quite possible some solutions will score higher than mine, depending on approach
# My solution would score the following.

# Functions @ Progressing Toward Standard
#   Using my pre-supplied function that has little flexibility
# Iteration @ Meets Standard
#   Using apply
# Data Structures @ Meets Standard
#   Using named vectors and converting to dfs

# Create a df of unique titles and authors for Indiana
book_search_df = unique(state_books[["Indiana"]][, c("clean_title", "Author")])

# apply over unique books to get meta data
book_meta_list = apply(book_search_df, 1, FUN = function(book_row){
  
  # run the api call
  book_meta = get_book_info(book_name = book_row["clean_title"], author_name = book_row["Author"])
  
  # extract isbn
  isbn_table = book_meta$industryIdentifiers[[1]]
  
  # get the metadata we want
  meta = c(
    "publisher" = book_meta$publisher,
    "isbn13" = isbn_table[isbn_table$type == "ISBN_13", "identifier"],
    "page_count" = book_meta$pageCount,
    "maturity_rating" = book_meta$maturityRating,
    "description" = book_meta$description
  )
  
  # combine output with original data
  out = c(book_row, meta)
  
  # convert to df
  out_df = as.data.frame(t(out))
  
  # return
  return(out_df)
  
})

# combine list into final df
book_meta_df = do.call(plyr::rbind.fill, book_meta_list)

```











